package tacos.model;

import java.util.Date;
import java.util.List;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.PrePersist;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
@Entity
/**
 * Why this Entity annotated doesn't need the @NoArgsConstructor as Ingredient.java?
 * The Taco entity class does not need an explicit @NoArgsConstructor because of two key reasons related to how the Lombok @Data annotation and the Java compiler work. 
Reason 1: The @Data annotation behavior 
Lombok's @Data annotation is a powerful and convenient shortcut. It bundles several other annotations, including @Getter, @Setter, @ToString, @EqualsAndHashCode, and crucially, @RequiredArgsConstructor. 
However, the constructor generated by @RequiredArgsConstructor only includes final fields and fields with a @NonNull constraint. In the Taco class: 
None of the fields (id, createdAt, name, ingredients) are final.
The fields with constraints (name and ingredients) use validation annotations (@NotNull, @Size) that are checked at runtime, not constructor generation time. 
Because there are no final fields or @NonNull annotations, the @RequiredArgsConstructor generated by @Data effectively produces a no-argument constructor anyway. 

Reason 2: The Java compiler's default constructor 
The Java compiler automatically provides a public, no-argument default constructor for any class that does not define any other explicit constructors. 
Since the @Data annotation on the Taco class does not create a constructor with arguments (as explained above), no constructors are explicitly defined. This allows the Java compiler to do its job and automatically add the required no-argument constructor that JPA needs. 
Contrast with the Ingredient class
In contrast, the Ingredient class did need an explicit @NoArgsConstructor because of its final fields: 
java
private final String id;
private final String name;
private final Type type;
Use code with caution.

Because these fields are final, @RequiredArgsConstructor would generate a constructor that takes arguments for each of them. If you were to add an explicit all-args constructor or use a Lombok constructor annotation that generates a parameterized constructor, the compiler would no longer provide the default no-args constructor. This would break JPA, which needs a way to create an instance of the class from the database record using a no-args constructor. By using @NoArgsConstructor(access = AccessLevel.PRIVATE, force = true), you specifically instruct Lombok to generate the required no-argument constructor for JPA, while preventing its misuse in your application code. 

 */
// Here, the data will be persisted in the "Taco" table
public class Taco {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)    
    private Long id;

    private Date createdAt;

    @NotNull
    @Size(min=5, message="Name must be at least 5 characters long")
    private String name;

    @NotNull(message="You must choose at least 1 ingredient")
    @Size(min=1, message="You must choose at least 1 ingredient")
    @ManyToMany(targetEntity = Ingredient.class)
    private List<Ingredient> ingredients;

    @PrePersist
    void createdAt() {
        this.createdAt = new Date();
    }
}

/**
 * Follow up about the @RequiredArgsConstructor and @NoArgsConstructor annotations:
 * What if I have a class that has some final fields and some non-final fields, in this case, do I need both annotation?
 * 
Yes, if your JPA entity class has a mix of final and non-final fields, you will need to use both @RequiredArgsConstructor and @NoArgsConstructor(access = AccessLevel.PROTECTED, force = true) to ensure it works correctly with both Lombok and JPA. 
Here is an example to illustrate why, followed by a breakdown of the roles each annotation plays.
Example class with mixed fields
Imagine a Product entity with some fields that are immutable (id and sku) and others that can be updated (name and price).
java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Data
@Entity
@AllArgsConstructor // Generates a constructor with all fields
@NoArgsConstructor(access = AccessLevel.PROTECTED, force = true) // Generates a no-args constructor
public class Product {

    @Id
    private final String sku;
    
    @Id
    private final Long id;

    @NonNull
    private String name;
    
    private double price;
}
Use code with caution.

In this case, simply using @Data would not be enough. @Data includes @RequiredArgsConstructor, which would generate a constructor that only includes the final fields. You would still need an @AllArgsConstructor if you want a constructor with all fields, and the @NoArgsConstructor for JPA. 
Breakdown of the annotations' roles
@RequiredArgsConstructor (or @AllArgsConstructor)
Purpose: To provide a convenient way for your code to create new, valid instances of the entity with all its essential, non-negotiable data.
How it works with mixed fields: A constructor is created that includes all final fields and any non-final fields that are annotated with @NonNull. The non-final fields that are not annotated with @NonNull are not included, as they can be set later using their setters.
Example from above: If we just used @RequiredArgsConstructor on the Product class, the generated constructor would take sku, id, and name as arguments. The price would be ignored. A separate @AllArgsConstructor is needed if you want all fields in the constructor. 
@NoArgsConstructor(access = AccessLevel.PROTECTED, force = true) 
Purpose: To satisfy JPA's requirement that all entity classes have a no-argument constructor.
How it works with mixed fields: The force = true flag is essential here. By default, Lombok will throw an error if it tries to generate a no-argument constructor for a class with final fields, as they cannot be initialized. The force = true flag overrides this behavior, and Lombok will initialize the final fields to null (or their default value) so JPA can create a proxy or an instance.
Example from above: The force = true flag allows Lombok to create a constructor that initializes sku and id to null and name to null, enabling JPA to create the object from a database row. 
The best practice for JPA entities
While the combination of these annotations technically works, it is generally considered an anti-pattern to use final fields in JPA entities. This is because JPA implementations often need to create proxy objects or set the state of entities during the persistence lifecycle. By using final fields, you restrict this ability and can introduce complex issues. 
A more robust and recommended approach for JPA entities is to:
Avoid final fields for persistent properties.
Use standard, non-final fields with @NonNull for validation where necessary.
Use @Data or combine @Getter, @Setter, and @NoArgsConstructor to provide the necessary constructors and accessors.
If you need immutable objects for other parts of your application, use DTOs (Data Transfer Objects) that are separate from your JPA entities. This keeps your domain model clean and aligned with the requirements of the JPA specification.  
 */
